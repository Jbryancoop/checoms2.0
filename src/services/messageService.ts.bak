import { db } from './firebase';
import {
  collection,
  addDoc,
  query,
  where,
  orderBy,
  onSnapshot,
  getDocs,
  getDoc,
  writeBatch,
  doc,
  setDoc,
  updateDoc,
  deleteDoc,
  deleteField,
  increment,
  serverTimestamp,
  Timestamp
} from 'firebase/firestore';
import { Message, Conversation, AnyUser } from '../types';

export class MessageService {
  private static messagesCollection = 'messages';
  private static conversationsCollection = 'conversations';

  // Send a message
  static async sendMessage(
    senderId: string,
    senderName: string,
    senderEmail: string,
    recipientId: string,
    recipientName: string,
    recipientEmail: string,
    content: string,
    imageUrl?: string
  ): Promise<string> {
    try {
      // Use the recipientId as-is (could be UID or Airtable ID)
      const messageData: any = {
        senderId,
        senderName,
        senderEmail,
        recipientId,
        recipientName,
        recipientEmail,
        content,
        timestamp: serverTimestamp(),
        status: 'sent',
        read: false,
      };

      if (imageUrl) {
        messageData.imageUrl = imageUrl;
      }

      const collectionRef = collection(db, this.messagesCollection);

      const docRef = await addDoc(collectionRef, messageData);

      // Update conversation - show "Image" if only image, or content if text is included
      const conversationPreview = content || (imageUrl ? 'Image' : '');
      await this.updateConversation(senderId, recipientId, conversationPreview);

      // Send push notification to recipient
      await this.sendMessageNotification(recipientId, senderName, conversationPreview);

      return docRef.id;
    } catch (error: any) {
      console.error('Error sending message:', error);
      throw error;
    }
  }

  // Get messages between two users
  static getMessages(
    userId1: string,
    userId2: string,
    callback: (messages: Message[]) => void
  ): () => void {
    console.log('üîç Setting up message listener for users:', userId1, userId2);

    // If userId2 doesn't have a UID, use the Airtable ID instead
    const recipientId = userId2.startsWith('rec') ? userId2 : userId2;

    const messagesRef = collection(db, this.messagesCollection);
    const q = query(
      messagesRef,
      where('senderId', 'in', [userId1, recipientId]),
      orderBy('timestamp', 'asc')
    );

    const unsubscribe = onSnapshot(
      q,
      (snapshot) => {
        console.log('üì® Firestore snapshot received:', snapshot.size, 'messages');
        const messages: Message[] = [];

        snapshot.forEach((docSnap) => {
          const data = docSnap.data();

          // Only include messages between these two users
          if ((data.senderId === userId1 && data.recipientId === recipientId) ||
              (data.senderId === recipientId && data.recipientId === userId1)) {

            // Skip messages that the current user has deleted
            if (data.deletedBy?.[userId1]) {
              console.log('‚è≠Ô∏è Skipping deleted message for user', userId1, ':', docSnap.id);
              return;
            }

            messages.push({
              id: docSnap.id,
              senderId: data.senderId,
              senderName: data.senderName,
              senderEmail: data.senderEmail,
              recipientId: data.recipientId,
              recipientName: data.recipientName,
              recipientEmail: data.recipientEmail,
              content: data.content,
              timestamp: (data.timestamp as Timestamp)?.toDate().toISOString() || new Date().toISOString(),
              status: data.status || 'sent',
              isFromCurrentUser: data.senderId === userId1,
            });
          }
        });

        console.log(`üì® Filtered to ${messages.length} messages (excluded deleted messages for user ${userId1})`);
        callback(messages);
      },
      (error: any) => {
        // Suppress permission errors when user is logged out
        if (error?.code === 'permission-denied' || error?.message?.includes('Missing or insufficient permissions')) {
          console.log('‚ö†Ô∏è Messages listener: User logged out, ignoring permission error');
        } else {
          console.error('‚ùå Error listening to messages:', error);
          console.error('‚ùå Error details:', error);
        }

        // Return empty messages on error to prevent app crash
        callback([]);
      }
    );

    return unsubscribe;
  }

  // Get conversations for a user
  static async getConversations(userId: string): Promise<Conversation[]> {
    try {
      console.log('üîç Getting conversations for user:', userId);

      const conversationsRef = collection(db, this.conversationsCollection);
      const q = query(
        conversationsRef,
        where('participants', 'array-contains', userId),
        orderBy('lastMessageTime', 'desc')
      );

      const snapshot = await getDocs(q);
      const conversations: Conversation[] = [];

      for (const docSnap of snapshot.docs) {
        const data = docSnap.data();

        // Skip if this user has deleted the conversation
        if (data.deletedBy?.[userId]) {
          console.log('‚è≠Ô∏è Skipping deleted conversation:', docSnap.id);
          continue;
        }

        const otherUserId = data.participants.find((id: string) => id !== userId);

        if (otherUserId) {
          // Determine which user info to show based on who is viewing the conversation
          let recipientInfo;
          if (data.senderInfo && data.recipientInfo) {
            // Use the appropriate user info based on who is viewing
            recipientInfo = userId === data.participants[0] ? data.recipientInfo : data.senderInfo;
          } else {
            // Fallback: fetch from Airtable
            try {
              const { AirtableService } = await import('./airtable');
              recipientInfo = await AirtableService.getUserById(otherUserId) || {
                id: otherUserId,
                'Full Name': 'Unknown User',
                'ProfilePic': null,
              };
            } catch (error) {
              console.warn('Failed to fetch user info for:', otherUserId);
              recipientInfo = {
                id: otherUserId,
                'Full Name': 'Unknown User',
                'ProfilePic': null,
              };
            }
          }

          conversations.push({
            id: docSnap.id,
            recipient: recipientInfo,
            lastMessage: data.lastMessage,
            lastMessageTime: (data.lastMessageTime as Timestamp)?.toDate().toISOString() || new Date().toISOString(),
            unreadCount: data.unreadCounts?.[userId] || 0,
            isOnline: data.isOnline || false,
          });
        }
      }

      console.log('‚úÖ Found conversations:', conversations.length);
      return conversations;
    } catch (error) {
      console.error('‚ùå Error getting conversations:', error);
      throw error;
    }
  }

  // Get conversations with real-time updates
  static getConversationsRealtime(userId: string, callback: (conversations: Conversation[]) => void): () => void {
    console.log('üîç Setting up real-time conversations listener for user:', userId);

    const conversationsRef = collection(db, this.conversationsCollection);
    const q = query(
      conversationsRef,
      where('participants', 'array-contains', userId),
      orderBy('lastMessageTime', 'desc')
    );

    return onSnapshot(q, async (snapshot) => {
      console.log('üì± Conversations snapshot received:', snapshot.docs.length, 'conversations');
      const conversations: Conversation[] = [];

      for (const docSnap of snapshot.docs) {
        const data = docSnap.data();

        // Skip if this user has deleted the conversation
        if (data.deletedBy?.[userId]) {
          console.log('‚è≠Ô∏è Skipping deleted conversation:', docSnap.id, 'deletedBy:', data.deletedBy);
          continue;
        }

        // Debug: Log conversation data to see what's being received
        console.log('üîç Processing conversation:', docSnap.id, 'deletedBy:', data.deletedBy, 'userId:', userId);

        const otherUserId = data.participants.find((id: string) => id !== userId);

        if (otherUserId) {
          // Determine which user info to show based on who is viewing the conversation
          let recipientInfo;
          if (data.senderInfo && data.recipientInfo) {
            // Use the appropriate user info based on who is viewing
            recipientInfo = userId === data.participants[0] ? data.recipientInfo : data.senderInfo;
          } else {
            // Fallback: fetch from Airtable
            try {
              const { AirtableService } = await import('./airtable');
              recipientInfo = await AirtableService.getUserById(otherUserId) || {
                id: otherUserId,
                'Full Name': 'Unknown User',
                'ProfilePic': null,
              };
            } catch (error) {
              console.warn('Failed to fetch user info for:', otherUserId);
              recipientInfo = {
                id: otherUserId,
                'Full Name': 'Unknown User',
                'ProfilePic': null,
              };
            }
          }

          conversations.push({
            id: docSnap.id,
            recipient: recipientInfo,
            lastMessage: data.lastMessage,
            lastMessageTime: (data.lastMessageTime as Timestamp)?.toDate().toISOString() || new Date().toISOString(),
            unreadCount: data.unreadCounts?.[userId] || 0,
            isOnline: data.isOnline || false,
          });
        }
      }

      console.log('‚úÖ Real-time conversations updated:', conversations.length);
      callback(conversations);
    }, (error: any) => {
      // Suppress permission errors when user is logged out
      if (error?.code === 'permission-denied' || error?.message?.includes('Missing or insufficient permissions')) {
        console.log('‚ö†Ô∏è Conversations listener: User logged out, ignoring permission error');
        callback([]);
      } else {
        console.error('‚ùå Error in conversations listener:', error);
        callback([]);
      }
    });
  }

  // Update conversation
  private static async updateConversation(
    senderId: string,
    recipientId: string,
    lastMessage: string
  ): Promise<void> {
    try {
      const conversationId = this.getConversationId(senderId, recipientId);
      const conversationRef = doc(db, this.conversationsCollection, conversationId);

      // Get both users' info from Airtable
      const { AirtableService } = await import('./airtable');
      const senderInfo = await AirtableService.getUserById(senderId);
      const recipientInfo = await AirtableService.getUserById(recipientId);

      // Check if conversation was previously deleted by either user
      const conversationSnap = await getDoc(conversationRef);
      const existingData = conversationSnap.exists() ? conversationSnap.data() : null;
      const wasSenderDeleted = existingData?.deletedBy?.[senderId];
      const wasRecipientDeleted = existingData?.deletedBy?.[recipientId];

      if (wasSenderDeleted) {
        console.log(`üîÑ Un-deleting conversation for sender: ${senderId}`);
      }
      if (wasRecipientDeleted) {
        console.log(`üîÑ Un-deleting conversation for recipient: ${recipientId}`);
      }

      const conversationData: any = {
        participants: [senderId, recipientId],
        lastMessage,
        lastMessageTime: serverTimestamp(),
        // Store both users' info so either can see the conversation
        senderInfo: senderInfo || {
          id: senderId,
          'Full Name': 'Unknown User',
          'ProfilePic': null,
        },
        recipientInfo: recipientInfo || {
          id: recipientId,
          'Full Name': 'Unknown User',
          'ProfilePic': null,
        },
        updatedAt: serverTimestamp(),
      };

      await setDoc(conversationRef, conversationData, { merge: true });

      // Increment unread count for recipient using atomic increment
      await updateDoc(conversationRef, {
        [`unreadCounts.${recipientId}`]: increment(1),
      });
      console.log('‚úÖ Incremented unread count for recipient:', recipientId);

      // Clear deletedBy for both users when a message is sent
      // Must be done separately after setDoc because deleteField() doesn't work with setDoc merge
      const fieldsToDelete: any = {};
      if (wasSenderDeleted) {
        fieldsToDelete[`deletedBy.${senderId}`] = deleteField();
      }
      if (wasRecipientDeleted) {
        fieldsToDelete[`deletedBy.${recipientId}`] = deleteField();
      }

      if (Object.keys(fieldsToDelete).length > 0) {
        await updateDoc(conversationRef, fieldsToDelete);
        console.log('‚úÖ Removed users from deletedBy:', Object.keys(fieldsToDelete));
      }

      console.log('‚úÖ Updated conversation:', conversationId);
    } catch (error) {
      console.error('‚ùå Error updating conversation:', error);
      // Don't throw here as it's not critical
    }
  }

  // Generate consistent conversation ID
  private static getConversationId(userId1: string, userId2: string): string {
    const sortedIds = [userId1, userId2].sort();
    return `${sortedIds[0]}_${sortedIds[1]}`;
  }

  // Mark messages as read
  static async markMessagesAsRead(
    senderId: string,
    recipientId: string
  ): Promise<void> {
    try {
      console.log('üìñ Marking messages as read from', senderId, 'to', recipientId);

      const messagesRef = collection(db, this.messagesCollection);
      const q = query(
        messagesRef,
        where('senderId', '==', senderId),
        where('recipientId', '==', recipientId),
        where('read', '==', false)
      );

      const snapshot = await getDocs(q);
      const batch = writeBatch(db);

      snapshot.docs.forEach(docSnap => {
        batch.update(docSnap.ref, { read: true, status: 'read' });
      });

      await batch.commit();
      console.log('‚úÖ Marked messages as read');
    } catch (error) {
      console.error('‚ùå Error marking messages as read:', error);
      throw error;
    }
  }

  // Get user by ID from both tables
  static async getUserById(userId: string): Promise<AnyUser | null> {
    try {
      console.log('üîç Getting user by ID:', userId);

      // Import AirtableService here to avoid circular dependency
      const { AirtableService } = await import('./airtable');
      return await AirtableService.getUserById(userId);
    } catch (error) {
      console.error('‚ùå Error getting user by ID:', error);
      return null;
    }
  }

  // Delete conversation for a specific user (soft delete)
  static async deleteConversation(conversationId: string, userId: string): Promise<void> {
    try {
      console.log('üóëÔ∏è Deleting conversation:', { conversationId, userId });

      // The conversationId is in format "userId1_userId2" (sorted)
      const [userId1, userId2] = conversationId.split('_');
      console.log('üóëÔ∏è Conversation participants:', { userId1, userId2 });

      const conversationRef = doc(db, this.conversationsCollection, conversationId);

      // Mark conversation as deleted for this user
      await updateDoc(conversationRef, {
        [`deletedBy.${userId}`]: serverTimestamp(),
      });

      console.log('‚úÖ Marked conversation as deleted for user');

      // Also mark all messages in this conversation as deleted for this user
      const messagesRef = collection(db, this.messagesCollection);

      // Query for messages from user1 to user2
      const q1 = query(
        messagesRef,
        where('senderId', '==', userId1),
        where('recipientId', '==', userId2)
      );

      // Query for messages from user2 to user1
      const q2 = query(
        messagesRef,
        where('senderId', '==', userId2),
        where('recipientId', '==', userId1)
      );

      const [snapshot1, snapshot2] = await Promise.all([
        getDocs(q1),
        getDocs(q2)
      ]);

      const totalMessages = snapshot1.docs.length + snapshot2.docs.length;
      console.log(`üóëÔ∏è Found ${totalMessages} messages to mark as deleted`);

      if (totalMessages > 0) {
        const batch = writeBatch(db);

        snapshot1.docs.forEach(docSnap => {
          batch.update(docSnap.ref, {
            [`deletedBy.${userId}`]: serverTimestamp(),
          });
        });

        snapshot2.docs.forEach(docSnap => {
          batch.update(docSnap.ref, {
            [`deletedBy.${userId}`]: serverTimestamp(),
          });
        });

        await batch.commit();
        console.log(`‚úÖ Successfully marked ${totalMessages} messages as deleted for user ${userId}`);
      } else {
        console.log('‚ö†Ô∏è No messages found to delete');
      }

      console.log('‚úÖ Successfully deleted conversation and all messages');
    } catch (error) {
      console.error('‚ùå Error deleting conversation:', error);
      throw error;
    }
  }

  // Delete a single message for a specific user (soft delete)
  static async deleteMessage(messageId: string, userId: string): Promise<void> {
    try {
      console.log('üóëÔ∏è Deleting message for user:', messageId, userId);

      const messageRef = doc(db, this.messagesCollection, messageId);

      // Mark message as deleted for this user
      await setDoc(messageRef, {
        [`deletedBy.${userId}`]: serverTimestamp(),
      }, { merge: true });

      console.log('‚úÖ Successfully marked message as deleted for user');
    } catch (error) {
      console.error('‚ùå Error deleting message:', error);
      throw error;
    }
  }

  // Initialize conversations from existing messages
  static async initializeConversationsFromMessages(userId: string): Promise<void> {
    try {
      console.log('üîÑ Initializing conversations from existing messages for user:', userId);

      const messagesRef = collection(db, this.messagesCollection);

      // Get all messages where user is sender or recipient
      const sentQuery = query(messagesRef, where('senderId', '==', userId));
      const receivedQuery = query(messagesRef, where('recipientId', '==', userId));

      const [sentSnapshot, receivedSnapshot] = await Promise.all([
        getDocs(sentQuery),
        getDocs(receivedQuery)
      ]);

      // Collect unique conversation pairs
      const conversationPairs = new Map<string, { otherUserId: string, lastMessage: string, lastMessageTime: Timestamp }>();

      // Process sent messages
      sentSnapshot.forEach((docSnap) => {
        const data = docSnap.data();
        const isDeleted = data.deletedBy?.[userId];
        if (data.recipientId && !isDeleted) {
          const convId = this.getConversationId(userId, data.recipientId);
          const existing = conversationPairs.get(convId);
          if (!existing || (data.timestamp as Timestamp)?.toMillis() > existing.lastMessageTime?.toMillis()) {
            console.log(`üì§ Adding sent message to conversation ${convId}: "${data.content}"`);
            conversationPairs.set(convId, {
              otherUserId: data.recipientId,
              lastMessage: data.content,
              lastMessageTime: data.timestamp as Timestamp
            });
          }
        } else if (isDeleted) {
          console.log(`‚è≠Ô∏è Skipping deleted sent message: ${docSnap.id}`);
        }
      });

      // Process received messages
      receivedSnapshot.forEach((docSnap) => {
        const data = docSnap.data();
        const isDeleted = data.deletedBy?.[userId];
        if (data.senderId && !isDeleted) {
          const convId = this.getConversationId(userId, data.senderId);
          const existing = conversationPairs.get(convId);
          if (!existing || (data.timestamp as Timestamp)?.toMillis() > existing.lastMessageTime?.toMillis()) {
            console.log(`üì• Adding received message to conversation ${convId}: "${data.content}"`);
            conversationPairs.set(convId, {
              otherUserId: data.senderId,
              lastMessage: data.content,
              lastMessageTime: data.timestamp as Timestamp
            });
          }
        } else if (isDeleted) {
          console.log(`‚è≠Ô∏è Skipping deleted received message: ${docSnap.id}`);
        }
      });

      console.log('üì± Found', conversationPairs.size, 'unique conversations to initialize');

      // Create/update conversation documents
      const { AirtableService } = await import('./airtable');

      for (const [convId, data] of conversationPairs.entries()) {
        const conversationRef = doc(db, this.conversationsCollection, convId);

        // Check if conversation exists and if current user has deleted it
        const conversationSnap = await getDoc(conversationRef);
        console.log(`üîç Checking conversation ${convId}: exists=${conversationSnap.exists()}`);
        if (conversationSnap.exists()) {
          const conversationData = conversationSnap.data();
          console.log(`üîç Conversation data:`, {
            convId,
            deletedBy: conversationData?.deletedBy,
            deletedByUserId: conversationData?.deletedBy?.[userId],
            userId
          });
          if (conversationData?.deletedBy?.[userId]) {
            console.log('‚è≠Ô∏è Skipping initialization for deleted conversation:', convId);
            continue;
          }
        }

        // Fetch user info
        const [senderInfo, recipientInfo] = await Promise.all([
          AirtableService.getUserById(userId),
          AirtableService.getUserById(data.otherUserId)
        ]);

        await setDoc(conversationRef, {
          participants: [userId, data.otherUserId],
          lastMessage: data.lastMessage,
          lastMessageTime: data.lastMessageTime,
          senderInfo: senderInfo || {
            id: userId,
            'Full Name': 'Unknown User',
            'ProfilePic': null,
          },
          recipientInfo: recipientInfo || {
            id: data.otherUserId,
            'Full Name': 'Unknown User',
            'ProfilePic': null,
          },
          updatedAt: serverTimestamp(),
        }, { merge: true }); // Use merge: true to preserve existing fields like deletedBy
      }

      console.log('‚úÖ Conversations initialized successfully');
    } catch (error) {
      console.error('‚ùå Error initializing conversations:', error);
      // Don't throw - this is a background initialization
    }
  }

  // Send push notification when a message is received
  private static async sendMessageNotification(
    recipientId: string,
    senderName: string,
    messageContent: string
  ): Promise<void> {
    try {
      console.log('üì± Sending push notification to recipient:', recipientId);

      // Get recipient's push token from Airtable
      const { AirtableService } = await import('./airtable');
      const pushToken = await AirtableService.getPushTokenByUID(recipientId);

      if (!pushToken) {
        console.log('‚ö†Ô∏è No push token found for recipient:', recipientId);
        return;
      }

      // Send notification
      const { NotificationService } = await import('./notifications');
      const truncatedMessage = messageContent.length > 100
        ? messageContent.substring(0, 100) + '...'
        : messageContent;

      await NotificationService.sendPushNotification(
        pushToken,
        `New message from ${senderName}`,
        truncatedMessage,
        { type: 'message', senderId: recipientId }
      );

      console.log('‚úÖ Push notification sent successfully');
    } catch (error) {
      console.error('‚ùå Error sending push notification:', error);
      // Don't throw - notification failure shouldn't block message sending
    }
  }
}
